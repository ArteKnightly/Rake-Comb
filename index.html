<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rake Comb Planner (p5.js)</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <style>
    :root { --bg:#0b0d10; --panel:#13171d; --ink:#e8eaed; --muted:#9aa0a6; }
    html,body { margin:0; height:100%; background:var(--bg); color:var(--ink); font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { display:flex; height:100%; width:100%; }
    .panel { width:280px; padding:12px 16px; background:var(--panel); display:flex; flex-direction:column; gap:10px; box-shadow:0 4px 16px rgba(0,0,0,.35); overflow-y:auto; }
    .h { font-weight:700; font-size:16px; letter-spacing:.2px; }
    label { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    label span { color:var(--muted); font-size:12px; margin-left:6px; }
    input[type=number] { width:100px; background:#0f1318; border:1px solid #20262f; color:var(--ink); padding:4px 6px; border-radius:6px; }
    .out { font-size:12px; color:var(--muted); line-height:1.35; }
    button { background:#0f1318; border:1px solid #2a323d; color:var(--ink); padding:6px 10px; border-radius:6px; cursor:pointer; margin-top:6px; }
    button:hover { background:#1a1f28; }
    .main { flex:1; display:flex; flex-direction:column; }
    #sketch { height: 32vh; min-height:160px; }
    #viewer3d { flex:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="h">Rake Comb Planner (mm)</div>
      <label>Tooth width <input id="tooth" type="number" value="10.0" step="0.1" min="0.5"></label>
      <label>Gap <input id="gap" type="number" value="50" step="0.1" min="0.2"></label>
      <label>Thickness <input id="th" type="number" value="25.4" step="0.1" min="4"></label>
      <label>Blade depth <input id="bd" type="number" value="12" step="0.1" min="2"></label>
      <label>Tooth taper <span>(mm on outer Z edge)</span> <input id="tch" type="number" value="2" step="0.1" min="0"></label>
      <label>Clearance <span>(mm on 6.35 hole)</span> <input id="clr" type="number" value="12" step="0.1" min="0"></label>
      <label>Total width <input id="total" type="number" value="180" step="0.1" min="5"></label>
      <div class="out" id="out"></div>
      <button id="exportSTL">Generate STL</button>
      <button id="copySTL" style="display:none;">Copy to Clipboard</button>
      <textarea id="stlOutput" style="display:none; width:100%; height:150px; font-family:monospace; font-size:10px; margin-top:6px; background:#0f1318; border:1px solid #20262f; color:var(--ink); padding:6px; border-radius:6px;"></textarea>
    </div>
    <div class="main">
      <div id="sketch"></div>
      <div id="viewer3d"></div>
    </div>
  </div>
  <script>
    // ---------- Params & helpers ----------
    const mmPerPx = 1.5;
    const ids = ['tooth','gap','th','bd','clr','total','tch'];
    function P(id){ return +document.getElementById(id).value; }
    function readParams(){
      return { tooth:P('tooth'), gap:P('gap'), th:P('th'), bd:P('bd'), clr:P('clr'), tch:P('tch'), total:P('total') };
    }
    function formatOut(p){
      const segW = p.tooth + p.gap; 
      const n = Math.ceil(p.total / segW); 
      const realized = n * segW; 
      const hole = 6.35 + p.clr;
      return {
        segW, n, realized, hole, 
        html:`Seg = ${segW.toFixed(2)} mm Â· Count=${n}<br>Total=${realized.toFixed(2)} mm (target ${p.total.toFixed(2)} mm)<br>Hole=${hole.toFixed(2)} mm`
      };
    }

    // ---------- 2D preview (NO WEBGL HERE) ----------
    new p5((p)=>{
      p.setup=()=>{
        p.createCanvas(window.innerWidth-300, document.getElementById('sketch').clientHeight).parent('sketch');
        ids.forEach(id=>document.getElementById(id).addEventListener('input', ()=>p.redraw()));
        p.noLoop(); p.redraw();
      };
      p.windowResized=()=>{ 
        p.resizeCanvas(window.innerWidth-300, document.getElementById('sketch').clientHeight); 
        p.redraw(); 
      };
      p.draw=()=>{
        const prm=readParams(); 
        const F=formatOut(prm); 
        document.getElementById('out').innerHTML=F.html;
        p.background(12); 
        p.translate(40, p.height/2);
        const seg = F.segW*mmPerPx; 
        const h = prm.th*mmPerPx;
        p.stroke(70); 
        p.line(0,0, seg*3, 0);
        for(let i=0;i<3;i++){
          const x = i*seg; 
          p.stroke(180); 
          p.noFill(); 
          p.rect(x,-h/2, seg, h); 
          p.noStroke(); 
          p.fill(130); 
          p.rect(x,-h/2, prm.tooth*mmPerPx, h);
        }
      };
    });

    // ---------- 3D viewer (WEBGL) ----------
    new p5((p)=>{
      p.setup=()=>{ 
        p.createCanvas(window.innerWidth-300, window.innerHeight- document.getElementById('sketch').clientHeight, p.WEBGL).parent('viewer3d'); 
      };
      p.windowResized=()=>{ 
        p.resizeCanvas(window.innerWidth-300, window.innerHeight- document.getElementById('sketch').clientHeight); 
      };

      function boxMM(cx,cy,cz,dx,dy,dz,mat){ 
        p.push(); 
        p.translate(cx,cy,cz); 
        if(mat) mat(); 
        p.box(dx,dy,dz); 
        p.pop(); 
      }
      
      function axes(len){ 
        p.push(); 
        p.strokeWeight(2); 
        // Red = X axis
        p.stroke(255,0,0); 
        p.line(0,0,0, len,0,0); 
        // Green = Y axis
        p.stroke(0,255,0); 
        p.line(0,0,0, 0,len,0); 
        // Blue = Z axis
        p.stroke(0,0,255); 
        p.line(0,0,0, 0,0,len); 
        p.pop(); 
      }

      function drawSleeve(prm){
        const segW = prm.tooth + prm.gap;
        const th = prm.th;
        const hole = 6.35 + prm.clr; 
        const rim = Math.max(0, (th - hole) / 2);
        
        if(rim > 0){
          // Square tube: top/bottom rails + left/right rails
          // Centered at x = segW/2 to span from x=0 to x=segW
          const cx = segW / 2;
          boxMM(cx,  th/2 - rim/2, 0, segW, rim, th, ()=>p.ambientMaterial(180));
          boxMM(cx, -th/2 + rim/2, 0, segW, rim, th, ()=>p.ambientMaterial(180));
          boxMM(cx, 0,  th/2 - rim/2, segW, th, rim, ()=>p.ambientMaterial(180));
          boxMM(cx, 0, -th/2 + rim/2, segW, th, rim, ()=>p.ambientMaterial(180));
        }
      }

      // Tooth: LEFT face at x=0 (origin); extends rightward by tooth width
      // Anchored to Z=-th/2; depth Dz = th/2 from Z=-th/2; taper on +Z at far end
      function drawTooth(prm){
        const Tw = prm.tooth;
        const th = prm.th;
        const Dz = th / 2;
        const Bd = prm.bd;
        const zTap = Math.max(0, Math.min(prm.tch, Dz));
        
        // Y coords: base at -th/2, extends down by blade depth
        const y0 = -th/2;
        const y1 = y0 - Bd;
        
        // X coords: LEFT face at origin (x=0), extends right by tooth width
        const xLeft = 0;
        const xRight = Tw;
        
        // Z coords: anchored to outer -Z edge, extends inward by depth Dz
        const z0a = -th/2;        // outer Z at base
        const z0b = z0a + Dz;     // inner Z at base
        const z1a = z0a;          // outer Z at far end (no taper on outer edge)
        const z1b = z0b - zTap;   // inner Z at far end (tapered)
        
        // Vertices: base (y0) then far (y1)
        const V = [
          [xLeft,  y0, z0a], // 0: left,  base, outer
          [xRight, y0, z0a], // 1: right, base, outer
          [xRight, y0, z0b], // 2: right, base, inner
          [xLeft,  y0, z0b], // 3: left,  base, inner
          [xLeft,  y1, z1a], // 4: left,  far,  outer
          [xRight, y1, z1a], // 5: right, far,  outer
          [xRight, y1, z1b], // 6: right, far,  inner
          [xLeft,  y1, z1b]  // 7: left,  far,  inner
        ];
        
        p.ambientMaterial(220);
        
        // Draw all 6 faces
        quad(0,1,2,3); // base face (y=y0)
        quad(4,5,6,7); // far face (y=y1)
        quad(0,1,5,4); // outer face (z=z0a/z1a)
        quad(1,2,6,5); // right face (x=xRight=0)
        quad(2,3,7,6); // inner face (z=z0b/z1b)
        quad(3,0,4,7); // left face (x=xLeft)
        
        function quad(a,b,c,d){ 
          const A=V[a], B=V[b], C=V[c], D=V[d]; 
          p.beginShape(p.TRIANGLES); 
          p.vertex(...A); p.vertex(...B); p.vertex(...C); 
          p.vertex(...A); p.vertex(...C); p.vertex(...D); 
          p.endShape(); 
        }
      }

      p.draw=()=>{
        const prm = readParams(); 
        const segW = prm.tooth + prm.gap; 
        const th = prm.th;

        p.background(10); 
        p.orbitControl(); 
        p.ambientLight(150); 
        p.directionalLight(255,255,255, 0.5, 0.7, -1);
        
        const S = 2; 
        p.scale(S);
        
        // Draw sleeve (extends from x=0 to x=segW)
        drawSleeve(prm);
        
        // Draw tooth (right face at x=0)
        drawTooth(prm);
        
        // Draw origin axes at (0,0,0) with red dot
        p.push();
        // Red dot at origin
        p.fill(255,0,0);
        p.noStroke();
        p.translate(0,0,0);
        p.sphere(0.5);
        p.pop();
        
        // Axes at origin
        axes(Math.max(segW, th) * 0.15);
        
        // Green reference line at x=0 (left side of sleeve/tooth)
        p.push();
        p.stroke(0,255,0); 
        p.strokeWeight(2);
        p.line(0, -th/2, -th/2, 0, th/2, th/2);
        p.pop();
      };
    });

    // ---------- STL Export (sleeve + tooth) ----------
    document.getElementById('exportSTL').addEventListener('click',()=>{
      const prm = readParams();
      const segW = prm.tooth + prm.gap;
      const th   = prm.th;
      const hole = 6.35 + prm.clr;
      const rim  = Math.max(0, (th - hole) / 2);
      const Bd   = prm.bd;

      let stl = 'solid rake\n';
      
      function facet(v1,v2,v3){
        // Calculate normal
        const ax = v2[0] - v1[0], ay = v2[1] - v1[1], az = v2[2] - v1[2];
        const bx = v3[0] - v1[0], by = v3[1] - v1[1], bz = v3[2] - v1[2];
        const nx = ay * bz - az * by;
        const ny = az * bx - ax * bz;
        const nz = ax * by - ay * bx;
        const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
        const nnx = len > 0 ? nx/len : 0;
        const nny = len > 0 ? ny/len : 0;
        const nnz = len > 0 ? nz/len : 0;
        
        stl += `facet normal ${nnx.toFixed(6)} ${nny.toFixed(6)} ${nnz.toFixed(6)}\n outer loop\n`+
               `  vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`+
               `  vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`+
               `  vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`+
               ` endloop\n endfacet\n`;
      }
      
      function addBox(cx,cy,cz,dx,dy,dz){
        const x0=cx-dx/2, x1=cx+dx/2;
        const y0=cy-dy/2, y1=cy+dy/2;
        const z0=cz-dz/2, z1=cz+dz/2;
        const v=[
          [x0,y0,z0],[x1,y0,z0],[x1,y1,z0],[x0,y1,z0],
          [x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]
        ];
        const q=[
          [0,1,2,3], // bottom
          [4,5,6,7], // top
          [0,1,5,4], // front
          [2,3,7,6], // back
          [0,3,7,4], // left
          [1,2,6,5]  // right
        ];
        for(const f of q){ 
          facet(v[f[0]], v[f[1]], v[f[2]]); 
          facet(v[f[0]], v[f[2]], v[f[3]]); 
        }
      }
      
      // Square sleeve rails (centered at segW/2)
      if(rim > 0){
        const cx = segW / 2;
        addBox(cx,  th/2 - rim/2, 0, segW, rim, th);
        addBox(cx, -th/2 + rim/2, 0, segW, rim, th);
        addBox(cx, 0,  th/2 - rim/2, segW, th, rim);
        addBox(cx, 0, -th/2 + rim/2, segW, th, rim);
      }
      
      // Tooth wedge (left face at x=0, extends right by tooth width)
      {
        const Tw = prm.tooth;
        const Dz = th / 2;
        const zTap = Math.max(0, Math.min(prm.tch, Dz));
        
        const y0 = -th / 2;
        const y1 = y0 - Bd;
        
        const xLeft = 0;
        const xRight = Tw;
        
        const z0a = -th / 2;
        const z0b = z0a + Dz;
        const z1a = z0a;
        const z1b = z0b - zTap;
        
        const V = [
          [xLeft,  y0, z0a], [xRight, y0, z0a], [xRight, y0, z0b], [xLeft,  y0, z0b],
          [xLeft,  y1, z1a], [xRight, y1, z1a], [xRight, y1, z1b], [xLeft,  y1, z1b]
        ];
        
        const faces = [
          [0,1,2,3], [4,5,6,7], [0,1,5,4], [1,2,6,5], [2,3,7,6], [3,0,4,7]
        ];
        
        for(const f of faces){
          facet(V[f[0]], V[f[1]], V[f[2]]);
          facet(V[f[0]], V[f[2]], V[f[3]]);
        }
      }
      
      stl += 'endsolid rake\n';
      
      // Display STL in textarea
      const textarea = document.getElementById('stlOutput');
      const copyBtn = document.getElementById('copySTL');
      textarea.value = stl;
      textarea.style.display = 'block';
      copyBtn.style.display = 'block';
    });
    
    // Copy STL to clipboard
    document.getElementById('copySTL').addEventListener('click', ()=>{
      const textarea = document.getElementById('stlOutput');
      textarea.select();
      navigator.clipboard.writeText(textarea.value).then(()=>{
        const btn = document.getElementById('copySTL');
        const orig = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(()=>{ btn.textContent = orig; }, 2000);
      });
    });
  </script>
</body>
</html>
